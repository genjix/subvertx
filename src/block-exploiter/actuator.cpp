#include "actuator.hpp"

#include <boost/algorithm/string/predicate.hpp>

#include "irc.hpp"
#include "error.hpp"

using std::placeholders::_1;
using std::placeholders::_2;

actuator::actuator(blockchain_ptr chain, irc_ptr irc_client)
  : chain_(chain), irc_client_(irc_client)
{
}

std::error_code actuator::query(const lexical& lex)
{
    if (lex.command() == "block_depth")
    {
        if (lex.arguments().size() != 1)
            return be_error::wrong_arguments;
        size_t depth = boost::lexical_cast<size_t>(lex.arguments()[0]);
        chain_->fetch_block(depth,
            std::bind(&actuator::handle_block_fetch,
                shared_from_this(), _1, _2, lex));
        return std::error_code();
    }
    else if (lex.command() == "block_hash")
    {
        if (lex.arguments().size() != 1)
            return be_error::wrong_arguments;
        hash_digest hash = hash_from_pretty(lex.arguments()[0]);
        chain_->fetch_block(hash,
            std::bind(&actuator::handle_block_fetch,
                shared_from_this(), _1, _2, lex));
        return std::error_code();
    }
    else if (lex.command() == "tx" || lex.command() == "transaction")
    {
        if (lex.arguments().size() != 1)
            return be_error::wrong_arguments;
        hash_digest hash = hash_from_pretty(lex.arguments()[0]);
        chain_->fetch_transaction(hash,
            std::bind(&actuator::handle_transaction_fetch,
                shared_from_this(), _1, _2, lex));
        return std::error_code();
    }
    else if (lex.command() == "last_depth")
    {
        if (!lex.arguments().empty())
            return be_error::wrong_arguments;
        chain_->fetch_last_depth(
            std::bind(&actuator::handle_last_depth_fetch,
                shared_from_this(), _1, _2));
        return std::error_code();
    }
    return be_error::invalid_command;
}

bool actuator::block_field(std::string& echo, const std::string& show,
    const message::block& blk)
{
    if (show == "hash")
    {
        echo += pretty_hex(hash_block_header(blk));
        return true;
    }
    else if (show == "version")
    {
        echo += boost::lexical_cast<std::string>(blk.version);
        return true;
    }
    else if (show == "previous_block_hash")
    {
        echo += pretty_hex(blk.previous_block_hash);
        return true;
    }
    else if (show == "merkle")
    {
        echo += pretty_hex(blk.merkle);
        return true;
    }
    else if (show == "timestamp")
    {
        echo += boost::lexical_cast<std::string>(blk.timestamp);
        return true;
    }
    else if (show == "bits")
    {
        echo += boost::lexical_cast<std::string>(blk.bits);
        return true;
    }
    else if (show == "nonce")
    {
        echo += boost::lexical_cast<std::string>(blk.nonce);
        return true;
    }
    else if (boost::starts_with(show, "transactions"))
    {
        lexical tx_lexer;
        if (tx_lexer.parse(show))
        {
            if (tx_lexer.arguments().size() != 1)
            {
                echo += 
                    boost::lexical_cast<std::string>(blk.transactions.size());
            }
            else
            {
                size_t tx_idx =
                    boost::lexical_cast<size_t>(tx_lexer.arguments()[0]);
                if (tx_idx >= blk.transactions.size())
                    return false;
                const message::transaction& tx = blk.transactions[tx_idx];
                echo += "[" + tx_echo(tx, tx_lexer) + "]";
            }
            return true;
        }
        else
            return false;
    }
    return false;
}

void actuator::handle_block_fetch(const std::error_code& ec,
    const message::block& blk, const lexical& lex)
{
    if (ec)
    {
        irc_client_->reply(ec.message());
        return;
    }
    std::string echo;
    for (const std::string& show: lex.show_results())
    {
        echo += show + "=";
        if (!block_field(echo, show, blk))
            echo += "???";
        echo += "  ";
    }
    irc_client_->reply(echo);
}

bool actuator::transaction_field(std::string& echo, const std::string& show,
    const message::transaction& tx)
{
    if (show == "hash")
    {
        echo += pretty_hex(hash_transaction(tx));
        return true;
    }
    else if (show == "version")
    {
        echo += boost::lexical_cast<std::string>(tx.version);
        return true;
    }
    else if (show == "locktime")
    {
        echo += boost::lexical_cast<std::string>(tx.locktime);
        return true;
    }
    else if (show == "total_output_value")
    {
        echo += boost::lexical_cast<std::string>(total_output_value(tx));
        return true;
    }
    else if (boost::starts_with(show, "inputs"))
    {
        lexical tx_lexer;
        if (tx_lexer.parse(show))
        {
            if (tx_lexer.arguments().size() != 1)
            {
                echo += 
                    boost::lexical_cast<std::string>(tx.inputs.size());
            }
            else
            {
                size_t tx_idx =
                    boost::lexical_cast<size_t>(tx_lexer.arguments()[0]);
                if (tx_idx >= tx.inputs.size())
                    return false;
                const message::transaction_input& input = tx.inputs[tx_idx];
                echo += "[" + input_echo(input, tx_lexer) + "]";
            }
            return true;
        }
        else
            return false;
    }
    else if (boost::starts_with(show, "outputs"))
    {
        lexical tx_lexer;
        if (tx_lexer.parse(show))
        {
            if (tx_lexer.arguments().size() != 1)
            {
                echo += 
                    boost::lexical_cast<std::string>(tx.outputs.size());
            }
            else
            {
                size_t tx_idx =
                    boost::lexical_cast<size_t>(tx_lexer.arguments()[0]);
                if (tx_idx >= tx.outputs.size())
                    return false;
                const message::transaction_output& output = tx.outputs[tx_idx];
                echo += "[" + output_echo(output, tx_lexer) + "]";
            }
            return true;
        }
        else
            return false;
    }
    return false;
}

std::string actuator::input_echo(const message::transaction_input& input,
    const lexical& lex)
{
    std::string echo;
    for (const std::string& show: lex.show_results())
    {
        echo += show + "=";
        if (show == "script")
            echo += input.input_script.pretty();
        else if (show == "sequence")
            echo += boost::lexical_cast<std::string>(input.sequence);
        else if (show == "previous_output")
        {
            echo += pretty_hex(input.previous_output.hash);
            echo += ":";
            echo += 
                boost::lexical_cast<std::string>(input.previous_output.index);
        }
        else
            echo += "???";
        echo += "  ";
    }
    return echo;
}
std::string actuator::output_echo(const message::transaction_output& output,
    const lexical& lex)
{
    std::string echo;
    for (const std::string& show: lex.show_results())
    {
        echo += show + "=";
        if (show == "script")
            echo += output.output_script.pretty();
        else if (show == "value")
            echo += boost::lexical_cast<std::string>(output.value);
        else
            echo += "???";
        echo += "  ";
    }
    return echo;
}

std::string actuator::tx_echo(const message::transaction& tx,
    const lexical& lex)
{
    std::string echo;
    for (const std::string& show: lex.show_results())
    {
        echo += show + "=";
        if (!transaction_field(echo, show, tx))
            echo += "???";
        echo += "  ";
    }
    return echo;
}
void actuator::handle_transaction_fetch(const std::error_code& ec,
        const message::transaction& tx, const lexical& lex)
{
    if (ec)
    {
        irc_client_->reply(ec.message());
        return;
    }
    irc_client_->reply(tx_echo(tx, lex));
}

void actuator::handle_last_depth_fetch(const std::error_code& ec, size_t depth)
{
    if (ec)
    {
        irc_client_->reply(ec.message());
        return;
    }
    irc_client_->reply(boost::lexical_cast<std::string>(depth));
}

