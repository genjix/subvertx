#include "irc.hpp"

#include <boost/algorithm/string.hpp>

using std::placeholders::_1;
using std::placeholders::_2;

const char* channel_name = "#electrum";

void error_exit(const std::string& errmsg)
{
    log_error() << errmsg;
    exit(1);
}

data_chunk as_chunk(const std::string& s)
{
    return data_chunk(s.begin(), s.end());
}

irc::irc(async_service& service)
  : service_(service)
{
}

void irc::run(actuator_ptr act)
{
    actuator_ = act;
    socket_ = std::make_shared<tcp::socket>(service_.get_service());
    resolver_ptr resolver =
        std::make_shared<tcp::resolver>(service_.get_service());
    query_ptr query =
        std::make_shared<tcp::resolver::query>("94.125.182.252",
            boost::lexical_cast<std::string>(6667));
    resolver->async_resolve(*query,
        std::bind(&irc::resolve_handler, shared_from_this(),
            _1, _2, resolver, query));
}

void irc::resolve_handler(const boost::system::error_code& ec,
    tcp::resolver::iterator endpoint_iterator, resolver_ptr, query_ptr)
{
    if (ec)
        error_exit(ec.message());
    socket_ = std::make_shared<tcp::socket>(service_.get_service());
    boost::asio::async_connect(*socket_, endpoint_iterator,
        std::bind(&irc::connect_handler, shared_from_this(), _1, _2));
}

void irc::connect_handler(const boost::system::error_code& ec, 
    tcp::resolver::iterator)
{
    if (ec)
        error_exit(ec.message());
    boost::asio::async_read_until(*socket_, data_, "\r\n",
        std::bind(&irc::read_line, shared_from_this(), _1, _2));
    send_raw_line("NICK block-exploiter");
    send_raw_line("USER block-exploiter 0 * :block-exploiter");
    send_raw_line(std::string(":source JOIN :") + channel_name);
}

void irc::read_line(const boost::system::error_code& ec,
    size_t bytes_transferred)
{
    if (ec)
        error_exit(ec.message());
    std::ostringstream oss;
    oss << &data_;
    const std::string line = oss.str();
    if (line.find("PRIVMSG") != std::string::npos)
    {
        std::vector<std::string> strs;
        boost::split(strs, line, boost::is_any_of(":"));
        const std::string& privmsg = strs[2];
        if (privmsg.size() > 0 && privmsg[0] == '@')
        {
           std::string expression(privmsg.begin() + 1, privmsg.end() - 2);
           boost::trim(expression);
           message(expression);
        }
    }
    boost::asio::async_read_until(*socket_, data_, "\r\n",
        std::bind(&irc::read_line, shared_from_this(), _1, _2));
}

void irc::handle_send(const boost::system::error_code& ec)
{
    if (ec)
        error_exit(ec.message());
}

void irc::send_raw_line(const std::string& message)
{
    shared_const_buffer buff(as_chunk(message + "\r\n"));
    async_write(*socket_, buff,
        std::bind(&irc::handle_send, shared_from_this(), _1));
}

void irc::message(const std::string& msg)
{
    lexical lex;
    if (!lex.parse(msg))
    {
        reply("expression parsing failed");
        return;
    }
    try
    {
        std::error_code ec = actuator_->query(lex);
        if (ec)
            reply(std::string("malformed command: ") + ec.message());
    }
    catch (...)
    {
        reply("problem with command");
    }
}

bool irc::reply(const std::string& line)
{
    send_raw_line(std::string("PRIVMSG ") + channel_name + " :" + line);
}

